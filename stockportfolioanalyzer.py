# -*- coding: utf-8 -*-
"""StockPortfolioAnalyzer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Atf9Lzg8dR2nNLhqFkk_VIo7yREoWmPc
"""

import tensorflow as tf
import pandas as pd
import numpy as np
import yfinance as yf
from finta import TA
import requests
from datetime import datetime, timedelta
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.ensemble import RandomForestClassifier
import warnings
import matplotlib.pyplot as plt
import streamlit as st
import time
warnings.filterwarnings('ignore')

# Custom AROON calculation
def calculate_aroon(df, window=14):
    aroon_up = []
    aroon_down = []

    for i in range(len(df)):
        if i < window:
            aroon_up.append(np.nan)
            aroon_down.append(np.nan)
            continue

        window_slice = df.iloc[i - window + 1:i + 1]

        days_since_high = window - window_slice['High'].values.argmax() - 1
        days_since_low = window - window_slice['Low'].values.argmin() - 1

        aroon_up.append(((window - days_since_high) / window) * 100)
        aroon_down.append(((window - days_since_low) / window) * 100)

    df['AROON_UP'] = aroon_up
    df['AROON_DOWN'] = aroon_down

    return df

class ComprehensiveStockAnalyzer:
    def __init__(self, symbol, alpha_vantage_key=None):
        self.symbol = symbol.upper()
        self.alpha_vantage_key = alpha_vantage_key
        self.ticker = yf.Ticker(self.symbol)
        self.scaler = StandardScaler()
        self.price_scaler = MinMaxScaler()

    def fetch_stock_data(self, period='2y', max_retries=3):
        """Fetch stock data with retry mechanism and rate limiting"""
        for attempt in range(max_retries):
            try:
                # Add delay between requests to avoid rate limiting
                if attempt > 0:
                    wait_time = attempt * 2
                    st.info(f"Rate limited. Waiting {wait_time} seconds before retry {attempt + 1}/{max_retries}...")
                    time.sleep(wait_time)
                
                # Create a new ticker instance for each attempt
                ticker = yf.Ticker(self.symbol)
                data = ticker.history(period=period)
                
                if data.empty:
                    if attempt < max_retries - 1:
                        continue
                    raise Exception(f"No data found for {self.symbol}")
                
                st.success(f"Successfully fetched data for {self.symbol}")
                return data
                
            except Exception as e:
                error_msg = str(e).lower()
                if "rate limit" in error_msg or "too many requests" in error_msg:
                    if attempt < max_retries - 1:
                        continue
                    else:
                        st.error(f"Rate limit exceeded for {self.symbol}. Please try again later.")
                        return None
                else:
                    st.error(f"Error fetching data for {self.symbol}: {e}")
                    return None
        
        return None

    def fetch_financial_data(self, max_retries=3):
        """Fetch financial data with retry mechanism"""
        for attempt in range(max_retries):
            try:
                if attempt > 0:
                    wait_time = attempt * 2
                    time.sleep(wait_time)
                
                ticker = yf.Ticker(self.symbol)
                info = ticker.info
                
                # Try to get other financial data, but don't fail if unavailable
                try:
                    financials = ticker.financials
                    balance_sheet = ticker.balance_sheet
                    cash_flow = ticker.cashflow
                except:
                    financials = None
                    balance_sheet = None
                    cash_flow = None

                return {
                    'info': info,
                    'financials': financials,
                    'balance_sheet': balance_sheet,
                    'cash_flow': cash_flow
                }
                
            except Exception as e:
                error_msg = str(e).lower()
                if "rate limit" in error_msg or "too many requests" in error_msg:
                    if attempt < max_retries - 1:
                        continue
                    else:
                        st.warning(f"Rate limit exceeded when fetching financial data for {self.symbol}")
                        return None
                else:
                    if attempt == max_retries - 1:
                        st.warning(f"Could not fetch financial data for {self.symbol}: {e}")
                    return None
        
        return None

    def analyze_fundamentals(self, financial_data):
        if not financial_data:
            return None

        info = financial_data['info']

        try:
            fundamentals = {
                'PE_ratio': info.get('trailingPE', 0),
                'Forward_PE': info.get('forwardPE', 0),
                'PEG_ratio': info.get('pegRatio', 0),
                'Price_to_book': info.get('priceToBook', 0),
                'Price_to_sales': info.get('priceToSalesTrailing12Months', 0),
                'EV_to_EBITDA': info.get('enterpriseToEbitda', 0),
                'ROE': info.get('returnOnEquity', 0),
                'ROA': info.get('returnOnAssets', 0),
                'Profit_margin': info.get('profitMargins', 0),
                'Operating_margin': info.get('operatingMargins', 0),
                'Gross_margin': info.get('grossMargins', 0),
                'Debt_to_equity': info.get('debtToEquity', 0),
                'Current_ratio': info.get('currentRatio', 0),
                'Quick_ratio': info.get('quickRatio', 0),
                'Cash_per_share': info.get('totalCashPerShare', 0),
                'Revenue_growth': info.get('revenueGrowth', 0),
                'Earnings_growth': info.get('earningsGrowth', 0),
                'EPS_growth': info.get('earningsQuarterlyGrowth', 0),
                'Dividend_yield': info.get('dividendYield', 0),
                'Payout_ratio': info.get('payoutRatio', 0),
                'Market_cap': info.get('marketCap', 0),
                'Beta': info.get('beta', 1),
                'Short_ratio': info.get('shortRatio', 0),
                'Institutional_ownership': info.get('heldByInstitutions', 0)
            }

            return fundamentals

        except Exception as e:
            st.error(f"Error analyzing fundamentals: {e}")
            return None

    def calculate_technical_indicators(self, data):
        df = data.copy()

        df['SMA_20'] = TA.SMA(df, 20)
        df['SMA_50'] = TA.SMA(df, 50)
        df['SMA_200'] = TA.SMA(df, 200)
        df['EMA_12'] = TA.EMA(df, 12)
        df['EMA_26'] = TA.EMA(df, 26)

        bb = TA.BBANDS(df)
        df['BB_upper'] = bb['BB_UPPER']
        df['BB_middle'] = bb['BB_MIDDLE']
        df['BB_lower'] = bb['BB_LOWER']

        df['RSI'] = TA.RSI(df)
        macd = TA.MACD(df)
        df['MACD'] = macd['MACD']
        df['MACD_signal'] = macd['SIGNAL']
        df['MACD_hist'] = macd['MACD'] - macd['SIGNAL']
        df['CCI'] = TA.CCI(df)
        df['Williams_R'] = TA.WILLIAMS(df)

        df = calculate_aroon(df)

        df['OBV'] = TA.OBV(df)
        df['Volume_SMA'] = df['Volume'].rolling(20).mean()

        df['ATR'] = TA.ATR(df)
        df['NATR'] = (df['ATR'] / df['Close']) * 100

        df['Price_change'] = df['Close'].pct_change()
        df['Volume_ratio'] = df['Volume'] / df['Volume_SMA']
        df['BB_position'] = (df['Close'] - df['BB_lower']) / (df['BB_upper'] - df['BB_lower'])
        df['Price_vs_SMA20'] = (df['Close'] - df['SMA_20']) / df['SMA_20']
        df['Price_vs_SMA50'] = (df['Close'] - df['SMA_50']) / df['SMA_50']

        return df.dropna()

    def momentum_analysis(self, data):
        latest = data.iloc[-1]

        momentum_signals = {
            'RSI_signal': 'BUY' if latest['RSI'] < 30 else 'SELL' if latest['RSI'] > 70 else 'NEUTRAL',
            'MACD_signal': 'BUY' if latest['MACD'] > latest['MACD_signal'] else 'SELL',
            'BB_signal': 'BUY' if latest['BB_position'] < 0.2 else 'SELL' if latest['BB_position'] > 0.8 else 'NEUTRAL',
            'SMA_trend': 'BULLISH' if latest['Close'] > latest['SMA_20'] > latest['SMA_50'] else 'BEARISH',
            'Volume_signal': 'STRONG' if latest['Volume_ratio'] > 1.5 else 'WEAK'
        }

        buy_signals = sum([1 for signal in momentum_signals.values() if signal in ['BUY', 'BULLISH', 'STRONG']])
        momentum_score = (buy_signals / len(momentum_signals)) * 100

        momentum_signals['Overall_momentum_score'] = momentum_score

        return momentum_signals

    def plot_trading_signals(self, data, momentum):
        fig, ax = plt.subplots(figsize=(16, 6))
        ax.plot(data.index, data['Close'], label='Close Price', color='blue')

        ax.set_title(f'{self.symbol} Trading Signals Overview')
        ax.set_xlabel('Date')
        ax.set_ylabel('Price')
        ax.legend()
        ax.grid()

        if momentum['RSI_signal'] == 'BUY':
            ax.scatter(data.index[-1], data['Close'].iloc[-1], color='green', label='RSI BUY Signal', marker='^', s=200)
        elif momentum['RSI_signal'] == 'SELL':
            ax.scatter(data.index[-1], data['Close'].iloc[-1], color='red', label='RSI SELL Signal', marker='v', s=200)

        ax.legend()
        st.pyplot(fig)
        plt.close(fig)

    def plot_charts(self, data):
        fig, axes = plt.subplots(3, 1, figsize=(16, 10))

        axes[0].plot(data.index, data['Close'], label='Close Price', color='blue')
        axes[0].plot(data.index, data['SMA_20'], label='SMA 20', linestyle='--')
        axes[0].plot(data.index, data['SMA_50'], label='SMA 50', linestyle='--')
        axes[0].set_title(f'{self.symbol} Price with SMA 20 and SMA 50')
        axes[0].legend()

        axes[1].plot(data.index, data['RSI'], label='RSI', color='purple')
        axes[1].axhline(70, color='red', linestyle='--')
        axes[1].axhline(30, color='green', linestyle='--')
        axes[1].set_title('Relative Strength Index (RSI)')
        axes[1].legend()

        axes[2].plot(data.index, data['MACD'], label='MACD', color='orange')
        axes[2].plot(data.index, data['MACD_signal'], label='Signal Line', color='black')
        axes[2].set_title('MACD and Signal Line')
        axes[2].legend()

        plt.tight_layout()
        st.pyplot(fig)
        plt.close(fig)

    def generate_report(self):
        st.write(f"\n{'='*60}")
        st.write(f"COMPREHENSIVE STOCK ANALYSIS REPORT")
        st.write(f"Symbol: {self.symbol}")
        st.write(f"Analysis Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        st.write(f"{'='*60}\n")

        stock_data = self.fetch_stock_data()
        if stock_data is None:
            st.error("Error: Could not fetch stock data")
            return

        financial_data = self.fetch_financial_data()

        technical_data = self.calculate_technical_indicators(stock_data)
        fundamentals = self.analyze_fundamentals(financial_data)
        momentum = self.momentum_analysis(technical_data)

        st.write("ðŸ“Š CURRENT PRICE & BASIC INFO")
        st.write(f"Current Price: ${technical_data['Close'].iloc[-1]:.2f}")
        if financial_data and financial_data['info']:
            info = financial_data['info']
            st.write(f"Market Cap: ${info.get('marketCap', 0):,}")
            st.write(f"52W Range: ${info.get('fiftyTwoWeekLow', 0):.2f} - ${info.get('fiftyTwoWeekHigh', 0):.2f}")
            st.write(f"Volume: {info.get('volume', 0):,}")
            st.write(f"Avg Volume: {info.get('averageVolume', 0):,}")

        st.write(f"\nðŸŽ¯ TRADING SIGNALS")
        st.write(f"Momentum Signals: {momentum}")

        st.write(f"\nðŸ“ˆ TECHNICAL ANALYSIS")
        st.write(f"RSI: {technical_data['RSI'].iloc[-1]:.2f}")
        st.write(f"MACD: {technical_data['MACD'].iloc[-1]:.2f}")
        st.write(f"Bollinger Position: {technical_data['BB_position'].iloc[-1]:.2f}")
        st.write(f"Volume Ratio: {technical_data['Volume_ratio'].iloc[-1]:.2f}")

        st.write(f"\nðŸ’° FUNDAMENTAL ANALYSIS")
        if fundamentals:
            st.write(f"P/E Ratio: {fundamentals['PE_ratio']:.2f}")
            st.write(f"PEG Ratio: {fundamentals['PEG_ratio']:.2f}")
            st.write(f"ROE: {fundamentals['ROE'] * 100:.2f}%")
            st.write(f"Debt to Equity: {fundamentals['Debt_to_equity']:.2f}")
            st.write(f"Revenue Growth: {fundamentals['Revenue_growth'] * 100:.2f}%")
        else:
            st.write("Fundamental data not available")

        st.write(f"\n{'='*60}")
        st.write("âš ï¸  DISCLAIMER: This is for educational purposes only.")
        st.write("    Not financial advice. Always do your own research.")
        st.write(f"{'='*60}\n")

        self.plot_charts(technical_data)
        self.plot_trading_signals(technical_data, momentum)

        return {
            'technical_data': technical_data,
            'fundamentals': fundamentals,
            'momentum': momentum
        }

class PortfolioAnalyzer:
    def __init__(self, symbols, weights=None):
        self.symbols = symbols
        self.weights = weights or [1/len(symbols)] * len(symbols)
        self.analyzers = {symbol: ComprehensiveStockAnalyzer(symbol) for symbol in symbols}

    def analyze_portfolio(self):
        portfolio_results = {}
        
        st.info(f"Analyzing portfolio with {len(self.symbols)} stocks. This may take a few minutes due to API rate limits...")
        
        # Create a progress bar
        progress_bar = st.progress(0)
        status_text = st.empty()

        for i, symbol in enumerate(self.symbols):
            status_text.text(f"Analyzing {symbol}... ({i+1}/{len(self.symbols)})")
            
            try:
                # Add delay between stocks to avoid rate limiting
                if i > 0:
                    time.sleep(2)  # 2 second delay between stocks
                
                results = self.analyzers[symbol].generate_report()
                portfolio_results[symbol] = results
                
            except Exception as e:
                st.error(f"Error analyzing {symbol}: {e}")
                portfolio_results[symbol] = None
            
            # Update progress bar
            progress_bar.progress((i + 1) / len(self.symbols))
        
        status_text.text("Analysis complete!")
        return portfolio_results

    def get_portfolio_summary(self, portfolio_results):
        valid_results = {k: v for k, v in portfolio_results.items() if v is not None}

        if not valid_results:
            st.error("No valid results to summarize")
            return

        overall_scores = []
        buy_signals = 0
        sell_signals = 0

        st.write(f"\n{'='*60}")
        st.write("PORTFOLIO SUMMARY")
        st.write(f"{'='*60}")

        for symbol, results in valid_results.items():
            if results and 'momentum' in results:
                momentum = results['momentum']
                overall_scores.append(momentum['Overall_momentum_score'])

                if momentum['RSI_signal'] == 'BUY':
                    buy_signals += 1
                elif momentum['RSI_signal'] == 'SELL':
                    sell_signals += 1

                st.write(f"{symbol}:\nRSI Signal: {momentum['RSI_signal']}\nMomentum Score: {momentum['Overall_momentum_score']:.1f}")

                # Plot individual pie chart for each stock
                labels = ['Momentum Score', 'Remaining']
                sizes = [momentum['Overall_momentum_score'], 100 - momentum['Overall_momentum_score']]
                colors = ['#4CAF50', '#FF7043']

                fig, ax = plt.subplots(figsize=(6, 6))
                ax.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=140)
                ax.axis('equal')
                ax.set_title(f'{symbol} Momentum Score')
                st.pyplot(fig)
                plt.close(fig)

        if overall_scores:
            avg_score = np.mean(overall_scores)
            st.write(f"\nPortfolio Average Momentum Score: {avg_score:.1f}/100")
            st.write(f"Buy Signals: {buy_signals}/{len(valid_results)}")
            st.write(f"Sell Signals: {sell_signals}/{len(valid_results)}")

            labels = ['Average Score', 'Remaining']
            sizes = [avg_score, 100 - avg_score]
            colors = ['#4CAF50', '#FF7043']

            fig, ax = plt.subplots(figsize=(8, 6))
            ax.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=140)
            ax.axis('equal')
            ax.set_title('Portfolio Average Momentum Score')
            st.pyplot(fig)
            plt.close(fig)

            if avg_score >= 70:
                st.success("âœ… Portfolio Status: STRONG")
            elif avg_score >= 50:
                st.warning("âš ï¸ Portfolio Status: MODERATE")
            else:
                st.error("âŒ Portfolio Status: WEAK")

if __name__ == "__main__":
    st.title("ðŸ“ŠComprehensive Stock Analyzer")

    st.markdown("---")
    
    # Add instructions
    st.markdown("""
    ### Instructions:
    - Enter stock symbols separated by commas
    - For Indian stocks, use .NS suffix (e.g., TCS.NS, INFY.NS, RELIANCE.NS)
    - For US stocks, use regular symbols (e.g., AAPL, MSFT, GOOGL)
    - Analysis may take 2-3 minutes due to API rate limits
    """)

    symbols_input = st.text_input(
        "Enter stock symbols:", 
        placeholder="e.g., TCS.NS, INFY.NS, RELIANCE.NS or AAPL, MSFT, GOOGL",
        key="portfolio_symbols_input"
    )
    
    # Add a button to clear cache/session
    if st.button("ðŸ”„ Clear Cache", help="Click if you're getting rate limit errors", key="clear_cache_button"):
        st.cache_data.clear()
        st.success("Cache cleared! You can now try analyzing again.")

    if st.button("ðŸš€ Analyze Portfolio", type="primary", key="analyze_portfolio_button"):
        if symbols_input:
            symbols = [sym.strip().upper() for sym in symbols_input.split(",")]
            
            # Validate symbols
            if len(symbols) > 10:
                st.error("Please limit to 10 stocks maximum to avoid rate limits.")
            else:
                st.info("Starting analysis... Please be patient as we fetch data from multiple sources.")
                
                with st.spinner("Initializing portfolio analyzer..."):
                    portfolio = PortfolioAnalyzer(symbols)
                
                portfolio_results = portfolio.analyze_portfolio()
                
                if portfolio_results:
                    portfolio.get_portfolio_summary(portfolio_results)
                else:
                    st.error("No results obtained. Please try again later or check your symbols.")
        else:
            st.warning("Please enter at least one stock symbol.")
    
    # Add footer with tips
    st.markdown("---")
    st.markdown("""
    ### ðŸ’¡ Tips:
    - If you get rate limit errors, wait 5-10 minutes before trying again
    - Try analyzing fewer stocks at once (2-3 maximum)
    - Use the 'Clear Cache' button if you encounter persistent errors
    - This tool is for educational purposes only - not financial advice
    """)